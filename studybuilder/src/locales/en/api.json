{
    "api": {
        "fields": {
            "body,uid": "UID",
            "body,name": "Name",
            "body,title": "Title",
            "body,value": "Value",
            "body,description": "Description",
            "body,order": "Order",
            "body,order_number": "Order Number",
            "body,library_name": "Library Name",
            "body,change_description": "Change Description",
            "body,aliases,a,name": "Name of Alias #{a}",
            "body,aliases,a,context": "Context of Alias #{a}",
            "body,descriptions,0,name": "Display Text",
            "body,descriptions,0,description": "Description",
            "body,descriptions,0,instruction": "Completion Instructions",
            "body,descriptions,0,sponsor_instruction": "Design Notes",
            "body,descriptions,a,name": "Name of Translation #{a}",
            "body,descriptions,a,language": "Language of Translation #{a}",
            "body,descriptions,a,description": "Description of Translation #{a}",
            "body,descriptions,a,instruction": "Completion Instructions of Translation #{a}",
            "body,descriptions,a,sponsor_instruction": "Design Notes of Translation #{a}"
        },
        "errors": {
            "arguments_type": "{field} arguments must be tuple, list or dictionary",
            "assertion_error": "Assertion failed for {field}: {error}",
            "bool_parsing": "{field} must be a valid boolean",
            "bool_type": "{field} must be a boolean",
            "bytes_invalid_encoding": "{field} must be valid {encoding} encoding: {encoding_error}",
            "bytes_too_long": "{field} must not have more than {max_length} bytes)",
            "bytes_too_short": "{field} must be at least {min_length} bytes)",
            "bytes_type": "{field} must be bytes",
            "callable_type": "{field} must be a callable",
            "complex_str_parsing": "{field} must be a valid complex string",
            "complex_type": "{field} must be a complex number or complex string",
            "dataclass_exact_type": "{field} must be an instance of {class_name}",
            "dataclass_type": "{field} must be a dictionary or instance of {class_name}",
            "date_from_datetime_inexact": "{field} must be a date without time",
            "date_from_datetime_parsing": "{field} must be a valid date or datetime: {error}",
            "date_future": "{field} must be in the future",
            "date_parsing": "{field} must be a valid date: {error}",
            "date_past": "{field} must be in the past",
            "date_type": "{field} must be a date",
            "datetime_from_date_parsing": "{field} must be a valid datetime: {error}",
            "datetime_future": "{field} must be in the future",
            "datetime_object_invalid": "{field} must be a valid date or datetime: {error}",
            "datetime_parsing": "{field} must be a valid datetime: {error}",
            "datetime_past": "{field} must be in the past",
            "datetime_type": "{field} must be a datetime",
            "decimal_max_digits": "{field} must not have more than {max_digits} digits in total",
            "decimal_max_places": "{field} must not have more than {decimal_places} digits after the decimal point",
            "decimal_parsing": "{field} must be a valid decimal number",
            "decimal_type": "{field} must be a decimal number",
            "decimal_whole_digits": "{field} must not have more than {whole_digits} digits before the decimal point",
            "default_factory_not_called": "### Default for {field} could not be produced due to earlier errors",
            "dict_type": "{field} must be a dictionary",
            "enum": "{field} must be one of: {expected}",
            "extra_forbidden": "{field} must not be provided",
            "finite_number": "{field} must be a finite number",
            "float_parsing": "{field} must be a valid float",
            "float_type": "{field} must be a float",
            "frozen_field": "{field} is read-only (frozen)",
            "frozen_instance": "{field} is read-only (frozen)",
            "frozen_set_type": "{field} must be a read-only set (frozenset)",
            "get_attribute_error": "{field} could not be read: {error}",
            "greater_than": "{field} must be greater than {gt}",
            "greater_than_equal": "{field} must be greater than or equal to {ge}",
            "int_from_float": "{field} must be an integer not a float",
            "int_parsing": "{field} must be a valid integer",
            "int_parsing_size": "{field} must be a valid integer within the size limit",
            "int_type": "{field} must be a integer",
            "invalid_key": "{field} must be a string",
            "is_instance_of": "{field} must be an instance of {class}",
            "is_subclass_of": "{field} must be a subclass of {class}",
            "iterable_type": "{field} must be an iterable (e.g. list, tuple)",
            "iteration_error": "An iteration error occurred for {field}: {error}",
            "json_invalid": "{field} contains invalid JSON: {error}",
            "json_type": "{field} must be a JSON",
            "less_than": "{field} must be less than {lt}",
            "less_than_equal": "{field} must be less than or equal to {le}",
            "list_type": "{field} must be a list",
            "literal_error": "{field} must be exactly one of: {expected}",
            "mapping_type": "{field} must be a mapping: {error}",
            "missing": "{field} must be provided",
            "missing_argument": "{field} must be provided",
            "missing_keyword_only_argument": "{field} must be provided",
            "missing_positional_only_argument": "{field} must be provided",
            "missing_sentinel_error": "### Required sentinel value was not provided",
            "model_attributes_type": "{field} must be a dictionary",
            "model_type": "{field} must be an instance of {class_name}",
            "multiple_argument_values": "Only one value may be provided for {field}",
            "multiple_of": "{field} must be a multiple of {multiple_of}",
            "needs_python_object": "{field} must be a python object not raw serialized data",
            "no_such_attribute": "Attribute {field} does not exist",
            "none_required": "{field} must be null",
            "recursion_loop": "Cyclic reference detected in data",
            "set_item_not_hashable": "{field} contains a non-hashable item",
            "set_type": "{field} must be a set",
            "string_pattern_mismatch": "{field} must match pattern {pattern}",
            "string_sub_type": "{field} {field} must be a text/string",
            "string_too_long": "{field} must not have more than {max_length} character(s)",
            "string_too_short": "{field} must be at least {min_length} character(s)",
            "string_type": "{field} must be a text/string",
            "string_unicode": "{field} must be valid Unicode text",
            "time_delta_parsing": "{field} must be a valid timedelta: {error}",
            "time_delta_type": "{field} must be a timedelta",
            "time_parsing": "{field} must be a valid time: {error}",
            "time_type": "{field} must be a time",
            "timezone_aware": "{field} must include timezone info",
            "timezone_naive": "{field} must not include timezone info",
            "too_long": "{field} must at most have {max_length} items. Got {actual_length} items",
            "too_short": "{field} must at least have {min_length} items. Got {actual_length} items",
            "tuple_type": "{field} must be a tuple",
            "unexpected_keyword_argument": "{field} must not be provided",
            "unexpected_positional_argument": "{field} must not be provided",
            "union_tag_invalid": "{discriminator} discriminator for {field} must be one of {expected_tags}. Got {tag}",
            "union_tag_not_found": "Discriminator {discriminator} for {field} not found",
            "url_parsing": "{field} must be a valid URL: {error}",
            "url_scheme": "{field} URL scheme must be one of: {expected_schemes}",
            "url_syntax_violation": "{field} must be a valid URL: {error}",
            "url_too_long": "{field} must not have more than {max_length} characters",
            "url_type": "{field} must be a URL",
            "uuid_parsing": "{field} must be a valid UUID: {error}",
            "uuid_type": "{field} must be a UUID",
            "uuid_version": "{field} must UUID {expected_version}",
            "value_error": "{field} is invalid: {msg}"
        }
    }
}